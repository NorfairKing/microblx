# u5c: fiveC compliant function block composition
#+STARTUP: showall
#+STARTUP: hidestars



* Important Links

- http://gcc.gnu.org/onlinedocs/cpp/Macros.html
- http://luajit.org/ext_ffi.html
- http://www.zeromq.org/intro:start
- https://live.gnome.org/GObjectIntrospection/

- http://www.isotton.com/devel/docs/C++-dlopen-mini-HOWTO/C++-dlopen-mini-HOWTO.html

  Using C++ components must be possible. Should be no problem if
  interface functions are defined using extern "C" {}.

- ffi reflection
  - http://www.corsix.org/lua/reflect/api.html
  - http://www.corsix.org/lua/reflect/reflect.lua

* Requirements

  - *Block model*: in, in-event/out ports

  - a block must have life-cycle.

  - Meta-data: used to define constraints on blocks, periodicity,
    etc. JSON? or pure lua

  - Ports: in/outs (correspond to in-args and out-args + retval)

  - Composition of blocks. different methods possible:
    - using functional programming
    - specifying all connections. this connections-spec can then be
      compiled into one single new function block or just
      instantiated.

  - Pure C and Lua. Light, embeddable.

  - Dynamic creation of interfaces: ie. dynamic creation of youbot arms.
    - dynamically adding ports vs. dynamically instatiation
      subcomponents. For the youbot subcomponents would work
      nicely. But if you want to handle an unkown amount of identical
      devices (minor#) the dynamical version is better. Thread safety,
      no statics!

* Example use cases that must be nicely satisfied
  - youbot driver: autodetection of arms
  - local function calls: i.e. how to plug services
  - 


Interaction model: defines what happens on read-write to a port,
i.e. buffering, rendevouz, sending via network. See also Ptolomy.

* Elements

  - Should we separate between types and instances: ComponentDef
    vs. ComponentInst? Probably yes!

** Components:
   define:
   - set of typed in and out ports
   - configuration
   - activity
   issues:
   - thread safety: instances must not share mutable data!

   interface representation
   - declarative yaml vs. procedural C interface. -> both necessary,
     even if the former should be preferred normally.

   - Should modify data in-place. The system will make the copy by
     default. That makes it easy to switch to zero copy. But the flow
     of data must be represented in the meta-data (two options:
     inport->outport tag or bidirectional port.)

** Ports
   
   Bidirectional ports are useful for properties that can be read or
   written. Possible to "disable", e.g. writing/reading will cause an
   error. Or should this be in the interaction? *-> no, whether a
   parameter can be changed at runtime or not depends on the block*
   
   - Port states: PORT_DISBALED | PORT_ENABLED
     

   

*** Triggering
    
    Distinguish between =triggered= and =stepped=? I.e. a component
    must be triggered by the availability of data before it can be
    stepped.

    Trigger specification language?
    trigger{(p1:new or p2:new) and p3:data}

    =new=: new data available
    =data=: old or new, but not none
    =dontcare=: whatever

    Maybe triggering should be an additional debugging layer.



** Interactions
   this is a special component that implements read and write and that
   can define ports to represent different
   information. e.g. statistics, errors, etc.
      
   - communication like interactions:
     - dataport: just store one sample, no locks.
     - buffer: store multiple.
     - multiplexer: one in- multiple

   - control oriented interactions:
     - may block the writer/reader

   - Can all locking be contained in interactions?
     E.g. multiplexer:



** Function calls on Function Blocks
   
   fb {
     pin i1, i2;
     pout out1;
     pout out2;
     pout out3;
   }

   call{name="foo", in={i1,i2}, out={out1&out2&out3}}
   
   foo(1,2} -> <out1>, <out2>, <out3>

   Use cases for this

   - pluggable functions: i.e. itasc solver
   - causing side-effects, ie. print_this

     Making this explicit adds structure, but its not a fundamental
     requirement. All you need is the ability to drop in a custom fb
     into an existing composition, i.e. a parametrizable composite.

** Type (only fixed size)

   - universally unique and human readable ID
     (or better hash struct def?)
   - variable sized data: e.g. a json message.
   - ffi spec. should this be optional or not?
   - attributes: fixed size/variable size
   - serialization
     - serialize/deserialize functions
     - type: boost serial, GooglePB, ...
     - autoserialize using ffi spec info?!

** Value representation
   - type
   - attributes: VARIABLE_SZ
   - serialization type: STRUCT | CUSTOM |
   - void data*


* Compilation
  
  It must be possible to compile two or more blocks, their connections
  and a schedule into a new block, that exposes a specified subset of
  the interface.


* Big questions

** Types
   =local tm = ffi.cast('TimeMsg*', tm_rtt:tolud())=

  - Types safety must be guaranteed. Hash types in some
    way. I.e. sha256 the struct def?

  - To which extent can we avoid boxing and explicit serialization. I
    think the latter is mandatory for non-trivial structs. We _must_
    also be able to support protocol buffers, boost serialization etc.

   *Options*:

  - Constrain to structs? C++ Objects can be mapped to structs
    (potentially automatically) but that may be non-intuitve. Ok for
    first go.

  - Support full type serialization. Necessary eventually.  But
    serialization should only take place when necessary, e.g. upon
    leaving a process boundary.

  - Requirements
    + types must be *uniquely identified* throughout a (distributed
      system). That can be the name or some hash calculated from the
      struct definition, etc.

    + types must be *registered* with Lua such it knows how to
      interpret these. Probably there will be several classes: 

      1. plain structs (easy using ffi)
      2. protocol buffers
      3. ROS types
      4. luabind
      5. ...


* Compilation
  
  A composition of blocks needs to be compilable into a new block.

* Future Ideas

** C only definition?

    - How to define type ports, configuration, etc.

** event driven ports

  How to support event-driven ports? when storing data in an event
  port, set owner component as runnable. Or instead offer a trigger
  method that can be implemented by the activity mechanism?  I.e. a
  static schedule will ignore the request, but a thread will be woken
  up?

** Auto-generating fblocks from Linux drivers (or interfaces) maybe
   from sysfs?



