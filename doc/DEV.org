# u5c: fiveC compliant function block composition
#+STARTUP: content
#+STARTUP: hidestars

* Next steps
  
** TODO load a configuration 
** TODO test communicating struct types
** TODO Test a minimal example with arrays of basic types
** TODO test compilation with g++ and clang++ (*sigh*)
   #ifdef __cplusplus
   # define REALLOC(ptr, size, type) ((type *)realloc(ptr, size))
   #else
   # define REALLOC(ptr, size, type) realloc(ptr, size)
   #endif

   #ifdef __cplusplus
   # define MALLOC(type, count) ((type *)calloc(count, sizeof(type)))
   #else
   # define MALLOC(type, count) (calloc(count, sizeof(type)))
   #endif

** TODO make an example of how to use C++
** TODO develop a generic luajit based block

** TODO locking
   - suggestion: rw-locks (or uRCU?)
     - trigger and inspecting interface must use reader-lock
     - changing state or interface must use writer lock
** TODO type comparison: remote use SHA1 (parts) and local type-ptr
** TODO introduce typeid's: (like git commitish)
   - full name: package/struct foo or package/foo_t or
   - partial hash of name: 0a407a4f51ff2bb1f92a6ae611cb63fb
** TODO three lists for block prototypes and one for instances
   - rationale: users shall choose sane names for their application
     blocks.
** DONE implement a buffered interaction
   CLOSED: [2013-06-24 Mon 21:42]
   - and test by writing data from the lua shell


** DONE implement a nice high level lua library.
   CLOSED: [2013-06-24 Mon 21:42]



** DONE extend the webserver with luajit support.
   CLOSED: [2013-06-24 Mon 21:42]
** DONE Test a minimal example with basic types
   CLOSED: [2013-06-19 Wed 10:42]
** DONE Fix leak upon failure: e.g. in alloc
   CLOSED: [2013-06-17 Mon 11:02]
   if realloc fails the original block is untouched and NULL is
   returned. Then we need to "unroll".


** DONE add functions to change life-cycle state and check that the FSM is respected.
   CLOSED: [2013-06-12 Wed 12:54]


** DONE Implement u5c_type_register/unregister
   CLOSED: [2013-06-11 Tue 13:09]
** DONE resolve types
   CLOSED: [2013-06-12 Wed 11:02]
   -> in u5c_resolve_types: need to check whether port has namein or outport is 
** DONE test hexdump interaction with variable types
   CLOSED: [2013-06-12 Wed 12:55]
** DONE add namespace to struct type's string spec and load into ffi
   CLOSED: [2013-06-13 Thu 15:56]



* Usefull stuff:
**  =valgrind --leak-check=full --track-origins=yes luajit rnd_to_hexdump.lua 2>&1 | less=
** [[http://p99.gforge.inria.fr/][P99]] - Preprocessor macros and functions for C99
** uthash
** libmowgli-2
** Lock-free and interprocess libs
*** [[http://www.liblfds.org/][liblfds]] the lock-free data structure library
*** http://concurrencykit.org/
** [[https://bitbucket.org/zserge/jsmn][jsmn ANSI C json parser with permissive mode]]
** Lua jit Application Programming Helper Libraries ([[https://github.com/Wiladams/LAPHLibs][github]])


** javascript graph drawing
   - https://github.com/cpettitt/dagre
   - http://d3js.org/
   - http://sigmajs.org/
   - http://www.graphdracula.net/
   - https://github.com/anvaka/VivaGraphJS
   - http://js-graph-it.sourceforge.net/index.html (nice!)
   - http://jsplumbtoolkit.com/doc/home (allows editing, flowcharts, FSM, but not layout :-( )
   - http://labs.unwieldy.net/moowheel/


** MD5 and SHA hashes
*** https://github.com/andresy/lua---md5
*** http://stackoverflow.com/questions/11167713/pure-lua-hashing-ripemd160-or-sha2/15417980#15417980

** http://lttng.org/urcu
* Focus
  - only in-out ports (maybe instead of multi-valued ports it's better
    to solve this at the type level, e.g. define a composite type
    instead. -> I really think so!)

  - dealing with C-struct types (later: automatic conversion to hdf5
    and rosmsg)

  - separate definition and instance.

* Milestones
  - [ ] Launch the random component stdalone and test it from the lua
    cmdline: configure seed, write, step, read.

  - [ ] Connect two components with an interaction and exchange data

  - [ ] Build a more complex topology

* Important Links

- http://gcc.gnu.org/onlinedocs/cpp/Macros.html
- http://luajit.org/ext_ffi.html
- http://www.zeromq.org/intro:start
- https://live.gnome.org/GObjectIntrospection/

- http://www.isotton.com/devel/docs/C++-dlopen-mini-HOWTO/C++-dlopen-mini-HOWTO.html

  Using C++ components must be possible. Should be no problem if
  interface functions are defined using extern "C" {}.

- ffi reflection
  - http://www.corsix.org/lua/reflect/api.html
  - http://www.corsix.org/lua/reflect/reflect.lua

* Requirements

  - *Block model*: in, in-event/out ports

  - a block must have life-cycle.

  - Meta-data: used to define constraints on blocks, periodicity,
    etc. JSON? or pure lua

  - Ports: in/outs (correspond to in-args and out-args + retval)

  - Composition of blocks. different methods possible:
    - using functional programming
    - specifying all connections. this connections-spec can then be
      compiled into one single new function block or just
      instantiated.

  - Pure C and Lua. Light, embeddable.

  - Dynamic creation of interfaces: ie. dynamic creation of youbot arms.
    - dynamically adding ports vs. dynamically instatiation
      subcomponents. For the youbot subcomponents would work
      nicely. But if you want to handle an unkown amount of identical
      devices (minor#) the dynamical version is better. Thread safety,
      no statics!

* Example use cases that must be nicely satisfied
  - youbot driver: autodetection of arms
  - local function calls: i.e. how to plug services
  - adding support for nasty C++ types.


  Interaction model: defines what happens on read-write to a port,
  i.e. buffering, rendevouz, sending via network. See also Ptolomy.

* Elements

  - Should we separate between types and instances: ComponentDef
    vs. ComponentInst? Probably yes!

** Components:
   define:
   - set of typed in and out ports
   - configuration
   - activity
   issues:
   - thread safety: instances must not share mutable data!

   interface representation
   - declarative yaml vs. procedural C interface. -> both necessary,
     even if the former should be preferred normally.

   - Should modify data in-place. The system will make the copy by
     default. That makes it easy to switch to zero copy. But the flow
     of data must be represented in the meta-data (two options:
     inport->outport tag or bidirectional port.)

** Ports
   
   Bidirectional ports are useful for properties that can be read or
   written. Possible to "disable", e.g. writing/reading will cause an
   error. Or should this be in the interaction? *-> no, whether a
   parameter can be changed at runtime or not depends on the block*
   
   - Port states: PORT_DISBALED | PORT_ENABLED

   - No OldData! Old is a too fuzzy concept, and causes a lot of
     problems, such as *ancient* data lingering and causing extreme
     motions etc.

     The OldData can be realized by an interaction which returns a
     piece of data on read while it can be considered new.




*** Triggering
    
    Distinguish between =triggered= and =stepped=? I.e. a component
    must be triggered by the availability of data before it can be
    stepped.

    1. Trigger specification language?
          =trigger{(p1:new or p2:new) and p3:data}=

    2. Components could define is_triggered C function:
       If not available assumes that is always triggered.
    
    =new=: new data available
    =data=: old or new, but not none
    =dontcare=: whatever

    Maybe triggering should be an additional debugging layer.

    *Open issue*
     Passive vs. active components:
     - should comm comps always be passive?
     - How to realize "pull" semantics, i.e. have a read trigger the
       generation of data.

       a) via a /pull/ communication comp: use the computational
       components =read= to trigger a producer to generate data that
       can be returned to the read callee.



** Interactions

   this is a special component that implements read and write and that
   can define ports itself to represent different
   information. e.g. statistics, errors, etc.

          
   - communication like interactions:
     - dataport: just store one sample, no locks.
     - buffer: store multiple.
     - multiplexer: one in- multiple

   - control oriented interactions:
     - may block the writer/reader, ie. CSP alike rendevouz:
       
    
   - Can all locking be contained in interactions?
     E.g. multiplexer:

     *Danger:* calling read/write on a port not connected to an
     interaction will call a segfault. Solutions: Always attach a
     dummy interaction, or use a port_write(port, data) function that
     checks instead of doing port->write yourself.

     Use cases:
     
     - Connect one-to-one
     - Connect one-to-many
     - Connect many-to-one


   (Where are locks needed?)
   
   - For connecting and disconnecting ports with
     interactions. Possibly this function pointer setting can be done
     using atomic ops.


   

** Buffering and zero copy semantics

   One-to-one:

   c1.a ->[i]-> c2.b

   - write(): interaction provided write is called and data stored in
     interaction buffer.

   - read(): interaction provided read is called and returns the data.

   - in this case the interaction requires no activity itself! But for
     a remote interaction (ZMQ) there might be a thread allocated for
     sending out data.

   - Copy semantics:
     1. With copying: c1 has it's own copy of the data. When it writes
        to port 'a', the interaction [i] makes a copy. c2.b again has
        it's own copy => *two copies*

     2. The c2 attaches its buffer to the read-port. When c1 writes,
        the interaction directly stores the data into the c2's read
        buffer.

     3. Zero copying: 
	
	Rule: Writing means releasing data. Could check this with
        reference count (ie. it is an error if refcnt is != 0 on
        write). Thus, buffer interactions only store data-objects
        (pointers to data).
	
	Collect when refcnt goes 0.

   - How to support both?
     1. DIY version of RTT
     2. v2 if possible

	
   

   One-to-many:

     c1.a -> [i] -> c2.b
                 -> c3.c 

     write as above.
     read must either a) lock b) 




** Function calls on Function Blocks
   
   fb {
     pin i1, i2;
     pout out1;
     pout out2;
     pout out3;
   }

   call{name="foo", in={i1,i2}, out={out1&out2&out3}}
   
   foo(1,2} -> <out1>, <out2>, <out3>

   Use cases for this

   - pluggable functions: i.e. itasc solver
   - causing side-effects, ie. print_this

     Making this explicit adds structure, but its not a fundamental
     requirement. All you need is the ability to drop in a custom fb
     into an existing composition, i.e. a parametrizable composite.

     A C representation of a call is necessary! Plugin modules!

** Type (only fixed size)

   - universally unique and human readable ID
     (or better hash struct def?)
   - variable sized data: e.g. a json message.
   - ffi spec. should this be optional or not?
   - attributes: fixed size/variable size
   - serialization
     - serialize/deserialize functions
     - type: boost serial, GooglePB, ...
     - autoserialize using ffi spec info?!

** Value representation
   - type
   - attributes: VARIABLE_SZ
   - serialization type: STRUCT | CUSTOM |
   - void data*


* Compilation
  
  It must be possible to compile two or more blocks, their connections
  and a schedule into a new block, that exposes a specified subset of
  the interface.


* Big questions

** Types
   =local tm = ffi.cast('TimeMsg*', tm_rtt:tolud())=

  - Types safety must be guaranteed. Hash types in some
    way. I.e. sha256 the struct def?

  - To which extent can we avoid boxing and explicit serialization. I
    think the latter is mandatory for non-trivial structs. We _must_
    also be able to support protocol buffers, boost serialization etc.

   *Options*:

  - Constrain to structs? C++ Objects can be mapped to structs
    (potentially automatically) but that may be non-intuitve. Ok for
    first go.

  - Support full type serialization. Necessary eventually.  But
    serialization should only take place when necessary, e.g. upon
    leaving a process boundary.

  - Requirements
    + types must be *uniquely identified* throughout a (distributed
      system). That can be the name or some hash calculated from the
      struct definition, etc.

    + types must be *registered* with Lua such it knows how to
      interpret these. Probably there will be several classes: 

      1. plain structs (easy using ffi)
      2. protocol buffers
      3. ROS types
      4. luabind
      5. ...


* Compilation
  
  A composition of blocks needs to be compilable into a new block.

* Future Ideas

** C only definition?

    - How to define type ports, configuration, etc.

** event driven ports

  How to support event-driven ports? when storing data in an event
  port, set owner component as runnable. Or instead offer a trigger
  method that can be implemented by the activity mechanism?  I.e. a
  static schedule will ignore the request, but a thread will be woken
  up?

** Auto-generating fblocks from Linux drivers (or interfaces) maybe
   from sysfs?



* Debunking (robotic) software framework myths

  - They are very complicated and hence must be developed my many
    people or by few people for a long time.

